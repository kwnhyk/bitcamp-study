package com.eomcs.lmsst.util;

//
/*Generalization 1단계:
//=> ArrayList와 LinkedList 사이의 공통 분모를 추출하여 수퍼 클래스를 정의한다.
//=> ArrayList와 LinkedList는 이렇게 정의한 수퍼 클래스를 상속 받는다.
//2단계
서브 클래스에 공통 분모를 물려주는 용도의 클래스는 인스턴스를 생성하지 못하게 추상 클래스로 선언
서브 클래스에서 구현할 메서드를 그냥 일반 메서드로 정의하면
서브 클래스를 정의하는 개발자가 해당 메소드를 오버라이딩 한다는 보장을 하지 못한다.
상속 받는 메서드 중에서 반드시 서브클래스에서 오버라이딩 해야 할 메서드라면
문법으로 표시를 하는 것이 좋다
이런 용도로 만든 문법이 "추상 메서드"이다
추상 메서드의 오버라이딩은 선택 사항이 아니라 필수 사항이다
 따라서 서브 클래스를 만드는 개발자는 반드시 이 추상 메서드를 구현해야 한다.

 추상메서드
 =>서브 클래스가 반드시 재정의 해야 할 메서드라면 수퍼 클래스에서 정의하지 않는다.
 또한 서브 클래스가 반드시 오버라이딩 하도록 강제하고 싶을 떄 사용하는 문법이다
 //3단계
   추상 메서드를 선언하는 의미
 	-서브 클래스에 구현을 강제하는 문법
   메서드 구현을 강제한다는 의미
   	-해당 객체가 반드시 갖춰야 할 기능을 선언하는 것
   	-객체의 사용법을 명시한는 효과
   	//초보자를 위한 실무 공식:
   	추상클 정의 추상메 설정
   	추상메서드는 인터페이스 문법을 사용하여 별도로 분리
   	클래스에서 사용 규칙을 따로 분리해서 정의해 두면
   	좀 더 다양한 하위 클래스를 저의 하고 다룰 수 있다.
   	추상 메소드가 대부분인 경우 인터페이스로 정의하는 것이 낫다
   	추상클래스의 목적이 하위클래스에게 공통 필드나 메서드를 상속해 주는것인데
   	대부분의 메서드가 추상 메서드라서 서브 클래스 입장에서 딱히 도움이 안되는 상황일 때
   	그냥 메소드 사용규칙만
   	 */
//추상 메서드를 인터페이스로 분리했으면
//implements
//List 에 선언된 모든 추상메서드를 반드시 구현해야 한다
//implement?
//메소드의 몸체를 정의 하는 것.
//즉 메서드의 코드를 정의하는것
//메서드가 해야 할 일이 무었인지 코드를 정의하는 것.
// 예) abstract void m1(); 추상 메서드
// 예2) void m1() {....} 메서드 구현

public abstract class AbstractList<E> implements List<E> {
	protected int size;

	public int size() {
		return size;
	}


}






